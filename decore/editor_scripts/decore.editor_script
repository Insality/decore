local M = {}

local file_creator = require("decore.editor_scripts.file_creator")

-- Define preference schema for the Decore Assistant
function M.get_prefs_schema()
	return {
		["decore.assistant.create_entity"] = editor.prefs.schema.boolean({default = true, scope = editor.prefs.SCOPE.PROJECT}),
		["decore.assistant.create_system"] = editor.prefs.schema.boolean({default = false, scope = editor.prefs.SCOPE.PROJECT}),
		["decore.assistant.create_command"] = editor.prefs.schema.boolean({default = false, scope = editor.prefs.SCOPE.PROJECT}),
		["decore.assistant.include_postwrap"] = editor.prefs.schema.boolean({default = false, scope = editor.prefs.SCOPE.PROJECT}),
		["decore.assistant.add_test"] = editor.prefs.schema.boolean({default = false, scope = editor.prefs.SCOPE.PROJECT}),
		["decore.assistant.add_test_system"] = editor.prefs.schema.boolean({default = false, scope = editor.prefs.SCOPE.PROJECT}),
		["decore.assistant.is_gui"] = editor.prefs.schema.boolean({default = false, scope = editor.prefs.SCOPE.PROJECT}),
		["decore.assistant.is_druid_widget"] = editor.prefs.schema.boolean({default = false, scope = editor.prefs.SCOPE.PROJECT}),
		["decore.assistant.is_collection"] = editor.prefs.schema.boolean({default = false, scope = editor.prefs.SCOPE.PROJECT}),
		["decore.assistant.register_in_systems"] = editor.prefs.schema.boolean({default = true, scope = editor.prefs.SCOPE.PROJECT}),
		["decore.assistant.register_in_entities"] = editor.prefs.schema.boolean({default = true, scope = editor.prefs.SCOPE.PROJECT}),
		["decore.assistant.register_in_tests"] = editor.prefs.schema.boolean({default = true, scope = editor.prefs.SCOPE.PROJECT}),
		["decore.assistant.register_in_spawner"] = editor.prefs.schema.boolean({default = true, scope = editor.prefs.SCOPE.PROJECT}),
	}
end

local function ends_with(str, ending)
	return ending == "" or str:sub(-#ending) == ending
end


local function save_file_from_dependency(dependency_file_path, output_file_path)
	local content = editor.get(dependency_file_path, "text")
	local file, err = io.open(output_file_path, "w")
	if not file then
		print("Error:", err)
		return false
	end
	file:write(content)
	file:close()

	print("Write file at", output_file_path)
	return true
end


local function get_integration_info()
	-- Get integration information directly from game.project
	local info = {
		has_systems_path = false,
		has_entities_path = false,
		has_tests_path = false,
		has_spawner_path = false,
		systems_path = "",
		entities_path = "",
		tests_path = "",
		spawner_path = ""
	}

	-- Get paths from game.project
	info.systems_path = editor.get("/game.project", "decore.assistant_systems_path") or ""
	info.entities_path = editor.get("/game.project", "decore.assistant_entities_path") or ""
	info.tests_path = editor.get("/game.project", "decore.assistant_tests_path") or ""
	info.spawner_path = editor.get("/game.project", "decore.assistant_spawner_path") or ""

	-- Check if paths exist
	info.has_systems_path = info.systems_path ~= ""
	info.has_entities_path = info.entities_path ~= ""
	info.has_tests_path = info.tests_path ~= ""
	info.has_spawner_path = info.spawner_path ~= ""

	return info
end


function M.get_commands()
	return {
		{
			label = "[Decore] Set as Bootstrap Collection",
			locations = { "Assets" },
			query = { selection = { type = "resource", cardinality = "one" } },
			active = function(opts)
				local path = editor.get(opts.selection, "path")
				return ends_with(path, ".collection")
			end,
			run = function(opts)
				local file = opts.selection
				print("Run script for", editor.get(file, "path"))
				local collection_path = editor.get(file, "path")

				local project_path = editor.external_file_attributes(".").path
				local game_project_path = project_path .. editor.get("/game.project", "path")

				local lines = {}
				do -- Open game.project file for reading
					local game_project_file = io.open(game_project_path, "r")
					if not game_project_file then
						print("Error: Could not open game.project file")
						return
					end

					-- Read all lines and modify the main_collection line
					for line in game_project_file:lines() do
						if line:match("main_collection%s*=.*") then
							line = "main_collection = " .. collection_path .. "c"
						end
						table.insert(lines, line)
					end
					game_project_file:close()
				end

				do -- Write the modified content back to the file
					local game_project_file = io.open(game_project_path, "w")
					if not game_project_file then
						print("Error: Could not open game.project file for writing")
						return
					end

					for _, line in ipairs(lines) do
						game_project_file:write(line .. "\n")
					end
					game_project_file:close()

					print("Successfully updated main_collection to " .. collection_path .. "c")
				end
			end
		},

		{
			label = "[Decore] Duplicate Folder with Assets Relink",
			locations = { "Assets" },
			query = { selection = { type = "resource", cardinality = "one" } },
			active = function(opts)
				local path = editor.get(opts.selection, "path")
				local attr = editor.resource_attributes(path)
				return attr.is_file
			end,
			run = function(opts)
				-- initial file name, will be replaced by the dialog
				local path = editor.get(opts.selection, "path")

				-- We take parent, due the editor scripts can't select folders now
				local folder_path = path:match("(.*/)") -- Example: /gui/window_animation/
				local folder_name = folder_path:match(".*/(.*)/") -- Example: window_animation
				--local target_folder_name = folder_name
				local parent_folder = folder_path:match("(.*/).*/") -- Example: /gui/


				--local create_file =
				local dialog = editor.ui.component(function(props)
					local target_folder_name, set_target_folder_name = editor.ui.use_state(folder_name)

					return editor.ui.dialog({
						title = "Duplicate Folder with Assets Relink",
						content = editor.ui.grid({
							padding = editor.ui.PADDING.LARGE,
							columns = {{}, {grow = true}, {}},
							children = {
								{
									editor.ui.label({
										text = "Current Folder Path",
										alignment = editor.ui.ALIGNMENT.RIGHT
									}),
									editor.ui.label({
										text = folder_path,
										color = editor.ui.COLOR.HINT,
										alignment = editor.ui.ALIGNMENT.LEFT
									})
								},
								{
									editor.ui.label({
										text = "New Folder Name",
										alignment = editor.ui.ALIGNMENT.RIGHT
									}),
									editor.ui.string_field({
										grow = true,
										value = target_folder_name,
										-- Typing callback:
										on_value_changed = set_target_folder_name
									})
								},
								{
									editor.ui.label({
										text = "New Folder Path",
										alignment = editor.ui.ALIGNMENT.RIGHT
									}),
									editor.ui.label({
										text = parent_folder .. target_folder_name,
										color = editor.ui.COLOR.HINT,
										alignment = editor.ui.ALIGNMENT.LEFT
									})
								},
							}
						}),
						buttons = {
							editor.ui.dialog_button({ text = "Cancel", cancel = true, result = false }),
							editor.ui.dialog_button({
								text = "Clone Folder",
								default = true,
								result = target_folder_name,
								enabled = target_folder_name ~= "" and target_folder_name ~= folder_name
							})
						}
					})
				end)

				local target_file_name = editor.ui.show_dialog(dialog({}))
				print("Result", target_file_name)

				if target_file_name then
					-- Clone folder with all assets, when rename folder and replace all references of "source_name" to "target_name" in filenames and their content
					save_file_from_dependency('/decore/editor_scripts/run_python_script.sh', "./build/run_python_script.sh")
					save_file_from_dependency('/decore/editor_scripts/rename_folder_with_assets.py', "./build/rename_folder_with_assets.py")
					return {
						{
							action = "shell",
							command = {
								"bash",
								"./build/run_python_script.sh",
								"./build/rename_folder_with_assets.py",
								"." .. folder_path,
								target_file_name,
							}
						}
					}
				end
			end
		},

		{
			-- A Decore Creator Panel, where you able to select a type of prefab/template you can create (system, entity, collection etc)
			-- Then show couple of options, like name, bool checkbox (is command included, is tests included, etc)
			-- Then button to create inside a selected folder the required files
			-- Base name is a name of folder selected

			-- Type: System
			-- Add a system_lua with name
			-- Option to add a command system

			-- Type: Entity
			-- subtype: collection, go, gui

			label = "[Decore] Assistant",
			locations = { "Assets" },
			query = { selection = { type = "resource", cardinality = "one" } },
			active = function(opts)
				local path = editor.get(opts.selection, "path")
				local attr = editor.resource_attributes(path)
				return attr.is_file
			end,
			run = function(opts)
				-- initial file name, will be replaced by the dialog
				local path = editor.get(opts.selection, "path")

				-- We take parent, due the editor scripts can't select folders now
				local folder_path = path:match("(.*/)") -- Example: /gui/window_animation/
				local folder_name = folder_path:match(".*/(.*)/") -- Example: window_animation

				-- Get information about integration points
				local integration_info = get_integration_info()

				local dialog = editor.ui.component(function(props)
					local target_folder_name, set_target_folder_name = editor.ui.use_state(folder_name)

					-- Load saved preferences for UI options
					local create_entity, set_create_entity = editor.ui.use_state(editor.prefs.get("decore.assistant.create_entity"))
					local create_system, set_create_system = editor.ui.use_state(editor.prefs.get("decore.assistant.create_system"))
					local create_command, set_create_command = editor.ui.use_state(editor.prefs.get("decore.assistant.create_command"))
					local include_postwrap, set_include_postwrap = editor.ui.use_state(editor.prefs.get("decore.assistant.include_postwrap"))
					local add_test, set_add_test = editor.ui.use_state(editor.prefs.get("decore.assistant.add_test"))
					local add_test_system, set_add_test_system = editor.ui.use_state(editor.prefs.get("decore.assistant.add_test_system"))
					local is_gui, set_is_gui = editor.ui.use_state(editor.prefs.get("decore.assistant.is_gui"))
					local is_druid_widget, set_is_druid_widget = editor.ui.use_state(editor.prefs.get("decore.assistant.is_druid_widget"))
					local is_collection, set_is_collection = editor.ui.use_state(editor.prefs.get("decore.assistant.is_collection"))

					-- Integration checkboxes
					local register_in_systems, set_register_in_systems = editor.ui.use_state(editor.prefs.get("decore.assistant.register_in_systems"))
					local register_in_entities, set_register_in_entities = editor.ui.use_state(editor.prefs.get("decore.assistant.register_in_entities"))
					local register_in_tests, set_register_in_tests = editor.ui.use_state(editor.prefs.get("decore.assistant.register_in_tests"))
					local register_in_spawner, set_register_in_spawner = editor.ui.use_state(editor.prefs.get("decore.assistant.register_in_spawner"))

					-- Calculate target folder path
					local target_folder_path = folder_path:match("(.*/).*/") .. target_folder_name .. "/"

					-- Calculate number of files that will be created
					local file_count = file_creator.count_files_to_create({
						create_entity = create_entity,
						create_system = create_system,
						include_command = create_command,
						is_gui = is_gui,
						is_druid_widget = is_druid_widget,
						is_collection = is_collection,
						include_test = add_test,
						add_test_system = add_test_system
					})

					-- Function to generate all creation options
					local function get_creation_options()
						return editor.ui.vertical({
							padding = editor.ui.PADDING.SMALL,
							spacing = editor.ui.SPACING.SMALL,
							children = {
								editor.ui.horizontal({
									children = {
										editor.ui.check_box({
											value = is_collection,
											on_value_changed = function(value)
												set_is_collection(value)
												editor.prefs.set("decore.assistant.is_collection", value)
											end
										}),
										editor.ui.label({
											text = "Is Collection",
											alignment = editor.ui.ALIGNMENT.LEFT
										})
									}
								}),
								editor.ui.horizontal({
									children = {
										editor.ui.check_box({
											value = is_gui,
											on_value_changed = function(value)
												set_is_gui(value)
												editor.prefs.set("decore.assistant.is_gui", value)

												-- Automatically disable druid widget if GUI is disabled
												if not value and is_druid_widget then
													set_is_druid_widget(false)
													editor.prefs.set("decore.assistant.is_druid_widget", false)
												end
											end
										}),
										editor.ui.label({
											text = "Is GUI",
											alignment = editor.ui.ALIGNMENT.LEFT
										})
									}
								}),
								editor.ui.horizontal({
									children = {
										editor.ui.check_box({
											value = is_druid_widget,
											enabled = is_gui,
											on_value_changed = function(value)
												set_is_druid_widget(value)
												editor.prefs.set("decore.assistant.is_druid_widget", value)
											end
										}),
										editor.ui.label({
											text = "Is Druid Widget",
											alignment = editor.ui.ALIGNMENT.LEFT,
											color = is_gui and editor.ui.COLOR.NORMAL or editor.ui.COLOR.DISABLED
										})
									}
								}),
								editor.ui.horizontal({
									children = {
										editor.ui.check_box({
											value = create_entity,
											on_value_changed = function(value)
												set_create_entity(value)
												editor.prefs.set("decore.assistant.create_entity", value)
											end
										}),
										editor.ui.label({
											text = "Create Entity",
											alignment = editor.ui.ALIGNMENT.LEFT
										})
									}
								}),
								editor.ui.horizontal({
									children = {
										editor.ui.check_box({
											value = create_system,
											on_value_changed = function(value)
												set_create_system(value)
												editor.prefs.set("decore.assistant.create_system", value)

												-- Automatically disable command if system is disabled
												if not value and create_command then
													set_create_command(false)
													editor.prefs.set("decore.assistant.create_command", false)
												end
											end
										}),
										editor.ui.label({
											text = "Create System",
											alignment = editor.ui.ALIGNMENT.LEFT
										})
									}
								}),
								editor.ui.horizontal({
									children = {
										editor.ui.check_box({
											value = create_command,
											enabled = create_system,
											on_value_changed = function(value)
												set_create_command(value)
												editor.prefs.set("decore.assistant.create_command", value)
											end
										}),
										editor.ui.label({
											text = "Create System Command",
											alignment = editor.ui.ALIGNMENT.LEFT,
											color = create_system and editor.ui.COLOR.NORMAL or editor.ui.COLOR.DISABLED
										})
									}
								}),
								editor.ui.horizontal({
									children = {
										editor.ui.check_box({
											value = include_postwrap,
											enabled = create_system,
											on_value_changed = function(value)
												set_include_postwrap(value)
												editor.prefs.set("decore.assistant.include_postwrap", value)
											end
										}),
										editor.ui.label({
											text = "Include PostWrap",
											alignment = editor.ui.ALIGNMENT.LEFT,
											color = create_system and editor.ui.COLOR.NORMAL or editor.ui.COLOR.DISABLED
										})
									}
								}),
								editor.ui.horizontal({
									children = {
										editor.ui.check_box({
											value = add_test,
											on_value_changed = function(value)
												set_add_test(value)
												editor.prefs.set("decore.assistant.add_test", value)
											end
										}),
										editor.ui.label({
											text = "Create Test Collection",
											alignment = editor.ui.ALIGNMENT.LEFT
										})
									}
								}),
								editor.ui.horizontal({
									children = {
										editor.ui.check_box({
											value = add_test_system,
											on_value_changed = function(value)
												set_add_test_system(value)
												editor.prefs.set("decore.assistant.add_test_system", value)
											end
										}),
										editor.ui.label({
											text = "Create Test System",
											alignment = editor.ui.ALIGNMENT.LEFT
										})
									}
								})
							}
						})
					end

					-- Function to generate integration options
					local function get_integration_options()
						-- Create a header for the integration section
						local children = {
							editor.ui.label({
								text = "Integration Options:",
								color = editor.ui.COLOR.TEXT,
								alignment = editor.ui.ALIGNMENT.LEFT
							})
						}

						-- Only show systems integration checkbox if relevant for the selected type
						if create_system and integration_info.has_systems_path then
							table.insert(children, editor.ui.horizontal({
								children = {
									editor.ui.check_box({
										value = register_in_systems,
										on_value_changed = function(value)
											set_register_in_systems(value)
											editor.prefs.set("decore.assistant.register_in_systems", value)
										end
									}),
									editor.ui.label({
										text = "Register in Systems (" .. integration_info.systems_path .. ")",
										alignment = editor.ui.ALIGNMENT.LEFT
									})
								}
							}))
						end

						-- Only show entities integration checkbox if relevant
						if create_entity and integration_info.has_entities_path then
							table.insert(children, editor.ui.horizontal({
								children = {
									editor.ui.check_box({
										value = register_in_entities,
										on_value_changed = function(value)
											set_register_in_entities(value)
											editor.prefs.set("decore.assistant.register_in_entities", value)
										end
									}),
									editor.ui.label({
										text = "Register in Entities (" .. integration_info.entities_path .. ")",
										alignment = editor.ui.ALIGNMENT.LEFT
									})
								}
							}))
						end

						-- Only show tests integration checkbox if including tests
						if add_test and integration_info.has_tests_path then
							table.insert(children, editor.ui.horizontal({
								children = {
									editor.ui.check_box({
										value = register_in_tests,
										on_value_changed = function(value)
											set_register_in_tests(value)
											editor.prefs.set("decore.assistant.register_in_tests", value)
										end
									}),
									editor.ui.label({
										text = "Register in Tests (" .. integration_info.tests_path .. ")",
										alignment = editor.ui.ALIGNMENT.LEFT
									})
								}
							}))
						end

						-- Only show spawner integration checkbox for collections or non-GUI entities
						if create_entity and (is_collection or not is_gui) and integration_info.has_spawner_path then
							table.insert(children, editor.ui.horizontal({
								children = {
									editor.ui.check_box({
										value = register_in_spawner,
										on_value_changed = function(value)
											set_register_in_spawner(value)
											editor.prefs.set("decore.assistant.register_in_spawner", value)
										end
									}),
									editor.ui.label({
										text = "Register in Spawner (" .. integration_info.spawner_path .. ")",
										alignment = editor.ui.ALIGNMENT.LEFT
									})
								}
							}))
						end

						-- If no integration paths are available, show help text
						if #children == 1 then
							table.insert(children, editor.ui.label({
								text = "No integration paths configured.",
								color = editor.ui.COLOR.HINT,
								alignment = editor.ui.ALIGNMENT.LEFT
							}))
						end

						return editor.ui.vertical({
							padding = editor.ui.PADDING.SMALL,
							spacing = editor.ui.SPACING.SMALL,
							children = children
						})
					end

					return editor.ui.dialog({
						title = "Decore Assistant",
						content = editor.ui.vertical({
							padding = editor.ui.PADDING.SMALL,
							spacing = editor.ui.SPACING.SMALL,
							children = {
								editor.ui.horizontal({
									padding = editor.ui.PADDING.SMALL,
									children = {
										editor.ui.label({
											text = "Name",
											alignment = editor.ui.ALIGNMENT.CENTER
										}),
										editor.ui.string_field({
											grow = true,
											value = target_folder_name,
											on_value_changed = set_target_folder_name
										})
									}
								}),
								editor.ui.horizontal({
									padding = editor.ui.PADDING.SMALL,
									children = {
										editor.ui.label({
											text = "Output",
											alignment = editor.ui.ALIGNMENT.CENTER
										}),
										editor.ui.label({
											text = target_folder_path .. " (" .. file_count .. " files)",
											color = editor.ui.COLOR.HINT,
											alignment = editor.ui.ALIGNMENT.LEFT
										})
									}
								}),
								get_creation_options(),
								get_integration_options()
							}
						}),
						buttons = {
							editor.ui.dialog_button({ text = "Cancel", cancel = true, result = false }),
							editor.ui.dialog_button({
								text = "Create",
								default = true,
								result = {
									name = target_folder_name,
									create_entity = create_entity,
									create_system = create_system,
									include_command = create_command,
									include_postwrap = include_postwrap,
									include_test = add_test,
									add_test_system = add_test_system,
									is_gui = is_gui,
									is_druid_widget = is_druid_widget,
									is_collection = is_collection,
									register_in_systems = register_in_systems,
									register_in_entities = register_in_entities,
									register_in_tests = register_in_tests,
									register_in_spawner = register_in_spawner
								}
							})
						}
					})
				end)

				local result = editor.ui.show_dialog(dialog({}))
				if result then
					-- Create the target folder
					local target_folder = folder_path:match("(.*/).*/") .. result.name .. "/"
					editor.create_directory(target_folder)
					if result.include_test then
						editor.create_directory(target_folder .. "test")
					end

					-- Create files based on the selected options
					file_creator.create_entity_files(result.name, result, target_folder)
				end
			end
		}
	}
end


return M
